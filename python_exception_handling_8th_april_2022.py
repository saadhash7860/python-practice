# Whenever we suspect there is a possible error we should do exception handling.

##var = 10/0
##print(var)
##print("welcome")
#Here we will get ZeroDivisionError: division by zero
# and also due to principle of pyhthon we dont get the next line executed.

##so here by using try and except block we can see that without exposing the code our program gets executed.

##try:
##    var = 10/0
##    print(var)
##
##except:                 # It is a default exception block and irrespective of the error it will be caught here.
##    print("sorry")      # In exception handling in pyhton a try must have atleast one except block.
##print("welcome")         # That is a try can have n no of except block.

##try:
##    var = "a" + 10
##    print(var)       #    Here we will get TypeError: can only concatenate str (not "int") to str
##except:              #    Irrespective of the error we can see it is catched here in the default catcher.
##    print("sorry")
##print("welcome")
    
##try:
##    var = "a"+10
##    print(var)
##except TypeError:
##    print("sorry for the error")
##except:
##    print("sorry")
##print("welcome")
# Here from line no 26 to 33 we can see we have more than on type of except block under a try.
# we can have except of a particular type also.

##try:
##    var = "a"+10
##    print(var)
##except TypeError as ex:   #It will give the cause of the error also,ex is just a variable which is used as a object reference
##    print(ex)
##except ZeroDivisionError as ex:
##    print(ex)

##except:   #default exception block and it should be always the last.
##    print("sorry")   
##print("welcome")

#To optimize code as python gives one error at a time.
##try:
##    var = "a" + 10
##    print(var)
##except(TypeError,ZeroDivisionError) as ex:
##    print(ex)
##
##except:  #default exception block.
##    print("sorry")

##try:
##    var = 10/4
##    print(var)
##except Exception as ex:  #this one line statement will find the error automatically no need to give other except block.
##    print(ex)

##else:    # else statetment only gets printed when there is no error in the try block
##    print("my else block")
##finally:  # finally statement will get printed in both the cases,that is whether in error or non error.
##    print("mhy block of finally")

# Sometimes we can raise our own exception even though it is not existing

##try:
##    var = 10
##    if var>4:
##        raise IndexError()
##except IndexError:
##    print("sorry")
    
##try:
##    var = 10
##    if var>4:
##        raise IndexError()
##except IndexError as ex:  #Here we can see that it will not give the meaning of the error as its not generated by the system its just raised ny us.
##    print(ex)    

##try:
##    var = 10
##    if var>4:
##        raise IndexError("my own error")
##     
##except IndexError as ex:  # Here we can see that it will give the meaning of the error as its already been given by the user.
##    print(ex)

# Here we trying to raise a error which is not there in python so we will get name error

##try:
##    var = 10
##    if var>4:
##        raise Netzwerk_Error("my own error")
    
##except Netzwerk_Error as ex:
##    print(ex)

# Creating user defined exception
# we need to create a class with the exception name an derive the base class that we wonna create this will make our error valid.


class Netzwerk_Error(Exception):
    pass
try:
    var = 10
    if var>4:
        raise Netzwerk_Error("my own error")
    
except Netzwerk_Error:
    print("sorry")


class Netzwerk_Error(Exception):
    my_error = "User defined exception"
try:
    var = 10
    if var>4:
        raise Netzwerk_Error("my own error")
    
except Netzwerk_Error as ex:
    print(ex.my_error)














 
